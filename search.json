[
  {
    "objectID": "clases/index.html",
    "href": "clases/index.html",
    "title": "Preparandonos para el curso",
    "section": "",
    "text": "En este curso vamos a utilizar principalmente R y RStudio para nuestras clases. Si ya lo tienen instalado, mi recomendación es que actualicen a la última versión de RStudio, ya que además viene con Quarto (la otra herramientas que vamos a utilizar).\nNota para usuarios de MacOS\nAntes de instalar R, la recomendación es instalar primero Xcode y XQuartz.\n\n\nR se puede descargar desde la pagina del Comprehensive R Archive Network o CRAN. Desde ese lugar se puede descargar la version de R e instalar según su sistema operativo.\n\n\n\nEn la página de descarga de RStudio, elegir la versión según el sistema operativo que esten utilizando.\n\n\nTanto R como RStudio tiene paginas web en donde se pueden encontrar respuestas a algunas preguntas. En el caso de R estan “Frequently Asked Questions”(FAQ) de R, o para Windows R for Windows FAQ.\nOtra fuente de información son paginas web y foros como Stack Overflow RStudio community. Sin embargo, lo más probable es que tus dudas ya se encuentren resueltas en la web, asi que primero haz una búsqueda en Google usando palabras clave o copia y pega en el buscador el mensaje de error que te aparezca en la consola de R. Consejo: haz tus búsquedas y consultas en inglés, tendrás acceso a más y mejor información."
  },
  {
    "objectID": "clases/03-Tidydata.html",
    "href": "clases/03-Tidydata.html",
    "title": "Organizando los datos (Tidydata)",
    "section": "",
    "text": "Uno de los conceptos claves en el Tidyverse tiene que ver con la estructura de los datos que vamos a analizar, lo que se ha denominado Tidy Data. El poder estructurar los datos de esta forma nos permite trabajar de manera consistente con las librerias del Tidyverse y construir codigo que sea flexible, reproducible y ordenado.\nLa estructura de los datos consiste en que cada variable (o feature) tiene su propia columna. Cada observación esta en una fila, y cada celda contiene un solo valor o medición.\n\n\n\nFigura de (https://r4ds.had.co.nz/tidy-data.html)\n\n\nEn esta clase, vamos a explorar algunas tablas y ordenarlas para que tengan el formato necesario. Para ello vamos a ocupar el paquete tidyr (que es parte del tidyverse), el cual tiene algunas tablas de ejemplo.\n\n\nPrimero que nada, como hemos hecho en las clases anteriores, vamos a cargar en nuestro script la libreria tidyverse.\n\nlibrary(tidyverse)\n\nVamos a ocupar varias tablas que son parte de esta libreria y que van a servir de ejemplo. Las tablas: table1, table2, table3, table4a, table4b, table5.\nEl ejemplo de tabla idea, que tiene la estructura necesaria, es table1\n\ntable1\n\n# A tibble: 6 × 4\n  country      year  cases population\n  <chr>       <int>  <int>      <int>\n1 Afghanistan  1999    745   19987071\n2 Afghanistan  2000   2666   20595360\n3 Brazil       1999  37737  172006362\n4 Brazil       2000  80488  174504898\n5 China        1999 212258 1272915272\n6 China        2000 213766 1280428583\n\n\n\n\n\n\n\nEl primer comando que vamos a mirar es pivot_wider. Para entender bien lo que hace, veamos primero table2.\n\ntable2\n\n# A tibble: 12 × 4\n   country      year type            count\n   <chr>       <int> <chr>           <int>\n 1 Afghanistan  1999 cases             745\n 2 Afghanistan  1999 population   19987071\n 3 Afghanistan  2000 cases            2666\n 4 Afghanistan  2000 population   20595360\n 5 Brazil       1999 cases           37737\n 6 Brazil       1999 population  172006362\n 7 Brazil       2000 cases           80488\n 8 Brazil       2000 population  174504898\n 9 China        1999 cases          212258\n10 China        1999 population 1272915272\n11 China        2000 cases          213766\n12 China        2000 population 1280428583\n\n\nVemos que esta tabla esta organizada, pero no de la manera “tidy”. En este caso la columna type no es un caracteristica de los paises, si no que los resultados reales estan en la columnna count. Para poder convertir esta tabla en el formato necesario, tenemos que expandirla. Esto lo podemos hacer con pivot_wider.\nA la función pivot_wider le pasamos dos opciones:\n\nnames_from: indica la columna desde donde vamos a sacar los nombres de las nuevas columnas.\nvalues_from: indica de donde vienen los valores para cada una de las nuevas columnas.\n\n\ntable2 %>%\n    pivot_wider(names_from = type,\n                values_from = count)\n\n# A tibble: 6 × 4\n  country      year  cases population\n  <chr>       <int>  <int>      <int>\n1 Afghanistan  1999    745   19987071\n2 Afghanistan  2000   2666   20595360\n3 Brazil       1999  37737  172006362\n4 Brazil       2000  80488  174504898\n5 China        1999 212258 1272915272\n6 China        2000 213766 1280428583\n\n\n\n\n\nVeamos ahora la tabla 3\n\ntable3\n\n# A tibble: 6 × 3\n  country      year rate             \n* <chr>       <int> <chr>            \n1 Afghanistan  1999 745/19987071     \n2 Afghanistan  2000 2666/20595360    \n3 Brazil       1999 37737/172006362  \n4 Brazil       2000 80488/174504898  \n5 China        1999 212258/1272915272\n6 China        2000 213766/1280428583\n\n\nVemos que esta tabla incluye en la columa rate el valor de los casos y la poblacion como un caracter (ej: 745/19987071). Para poder crear las nuevas columnas, lo que tenemos que hacer es crear nuevas columas en base a la existente, separando por el caracter /. Para eso podemos ocupar la función separate. Esta función ocupa:\n\nla columna a separar\ninto : un vector con los nombres de las columnas.\nsep : el caracter con el que vamos a separar\n\n\ntable3 %>%\n    separate(rate, into=c(\"cases\", \"population\"),\n             sep=\"/\") %>%\n    mutate(cases = parse_number(cases),\n           population = parse_number(population),\n           rate = cases/population)\n\n# A tibble: 6 × 5\n  country      year  cases population      rate\n  <chr>       <int>  <dbl>      <dbl>     <dbl>\n1 Afghanistan  1999    745   19987071 0.0000373\n2 Afghanistan  2000   2666   20595360 0.000129 \n3 Brazil       1999  37737  172006362 0.000219 \n4 Brazil       2000  80488  174504898 0.000461 \n5 China        1999 212258 1272915272 0.000167 \n6 China        2000 213766 1280428583 0.000167 \n\n\nEn este caso ademas tenemos que usar mutate, porque lo que genera la separación son columnas en donde los valores se consideran caracteres. Asi que tenemos que convertir las columnas en numeros, usando la función parse_number."
  },
  {
    "objectID": "clases/01-intro.html",
    "href": "clases/01-intro.html",
    "title": "Introducción a R",
    "section": "",
    "text": "En esta primera clase, vamos a explorar brevemente el lenguaje de programación R, conocer algunas de sus características y generar una visualización a partir de una tabla!"
  },
  {
    "objectID": "clases/01-intro.html#ejecutando-comandos-en-r",
    "href": "clases/01-intro.html#ejecutando-comandos-en-r",
    "title": "Introducción a R",
    "section": "Ejecutando comandos en R",
    "text": "Ejecutando comandos en R\nDesde la consola, es posible ejecutar comandos directamente. Por ejemplo podemos hacer operaciones aritmeticas\n\n1 + 1\n\n[1] 2\n\n\nTambien podemos generar números de manera secuencial\n\n1:10\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nTodo esto lo estuvimos haciendo desde la consola, pero no es la manera mas habitual de trabajar, ni tampoco la mejor práctica. Lo ideal es trabajar todo desde un script (básicamente un archivo de texto), el cual nos permite documentar el trabajo realizado.\nPara crear un nuevo script, podemos ir al boton verde de la parte superior izquierda, y elegir la opción R script. Una vez que creamos un script, podemos ir dejando en ese documento los comandos que vamos a ir utilizando."
  },
  {
    "objectID": "clases/01-intro.html#elementos-básicos-en-r",
    "href": "clases/01-intro.html#elementos-básicos-en-r",
    "title": "Introducción a R",
    "section": "Elementos básicos en R",
    "text": "Elementos básicos en R\nEn R encontramos 4 tipos de datos atómicos con los cuales podemos crear vectores:\n\nnumérico: enteros y reales\n12\n12.5\ncaracteres\n\"hola, soy un texto!\"\nlógicos\nTRUE\nFALSE\ncomplejos\n1 + 3i\n\nTambién existen dos tipos especiales que se pueden mezclar con los anteriores, NULL para cuando no existe un valor (por ejemplo, para declarar una variable sin asignar un valor) y NA (not assigned) cuando no hay una observación en una tabla.\nEl uso de NA es importante, porque permite mezclarse con otros tipos. Cualquier calculo que involucre NA va a resultar en NA. Por ejemplo:\n\nNA + 1\n\n[1] NA\n\n\nEl resultado es NA, porque R no sabe cual es la respuesta. Esto es igual si queremos identificar el número máximo en una lista de números:\n\nmax(10, 30, 5, NA)\n\n[1] NA\n\n\nPero algunas funciones, pueden ignorar ese NA con el parametro adecuado. Por ejemplo:\n\nmax(10, 30, 5, NA, na.rm=TRUE)\n\n[1] 30"
  },
  {
    "objectID": "clases/01-intro.html#asignación-de-variables",
    "href": "clases/01-intro.html#asignación-de-variables",
    "title": "Introducción a R",
    "section": "Asignación de variables",
    "text": "Asignación de variables\nLos resultados de las operaciones, calculos, etc, pueden ser guardados en variables para ser utilizados. Esto se hace con el operador <-. También es posible utilizar el operado =, pero en general se utiliza <-. Por ejemplo:\n\nejemplo <- 120\n\nY ahora podemos llamar la variable\n\nejemplo\n\n[1] 120\n\n\nEs posible hacer operaciones directamente con las variables:\n\nx <- 100\ny <- 123\n\nx + y\n\n[1] 223"
  },
  {
    "objectID": "clases/01-intro.html#vectores",
    "href": "clases/01-intro.html#vectores",
    "title": "Introducción a R",
    "section": "Vectores",
    "text": "Vectores\nUn vector es una coleccion ordenada de elementos, que pueden ser del mismo tipo o combinados. La función que se utiliza para generar los vectores es c. Por ejemplo:\n\nx <- c(1,5,10,14,20)\nx\n\n[1]  1  5 10 14 20\n\n\nTambién es posible crear un vector de caracteres\n\nnombres <- c(\"Francisco\", \"Andres\", \"Jorge\")\nnombres\n\n[1] \"Francisco\" \"Andres\"    \"Jorge\"    \n\n\ny combinar diferentes tipos:\n\ncombinacion <- c(\"Andres\", 50, 1e10)\ncombinacion\n\n[1] \"Andres\" \"50\"     \"1e+10\" \n\n\nPodemos acceder a los elementos individuales de un vector usando [] y el número del elemento. Es importante recordar que la númeracion parte desde 1 (versus Python, que parte desde 0).\n\nnombres[1]\n\n[1] \"Francisco\"\n\nnombres[3]\n\n[1] \"Jorge\"\n\n\nTambien podemos asignar nombres a los elementos de un vector. Por ejemplo:\n\nnumeros <- c(1,2,3)\nlabel <- c(\"uno\", \"dos\", \"tres\")\n\nnames(numeros) <- label\n\nnumeros\n\n uno  dos tres \n   1    2    3 \n\n\nY podemos acceder por nombre:\n\nnumeros[\"uno\"]\n\nuno \n  1 \n\n\nincluso usando un vector\n\nnumeros[c(\"uno\", \"tres\")]\n\n uno tres \n   1    3"
  },
  {
    "objectID": "clases/01-intro.html#exploración-inicial-de-los-datos",
    "href": "clases/01-intro.html#exploración-inicial-de-los-datos",
    "title": "Introducción a R",
    "section": "Exploración inicial de los datos",
    "text": "Exploración inicial de los datos\nVamos a llamar a una tabla llamada penguins y asignarla a una variable.\n\ntabla_pinguinos <- penguins\n\ny podemos visualizar la tabla\n\ntabla_pinguinos\n\n# A tibble: 344 × 8\n   species island    bill_length_mm bill_depth_mm flipper_…¹ body_…² sex    year\n   <fct>   <fct>              <dbl>         <dbl>      <int>   <int> <fct> <int>\n 1 Adelie  Torgersen           39.1          18.7        181    3750 male   2007\n 2 Adelie  Torgersen           39.5          17.4        186    3800 fema…  2007\n 3 Adelie  Torgersen           40.3          18          195    3250 fema…  2007\n 4 Adelie  Torgersen           NA            NA           NA      NA <NA>   2007\n 5 Adelie  Torgersen           36.7          19.3        193    3450 fema…  2007\n 6 Adelie  Torgersen           39.3          20.6        190    3650 male   2007\n 7 Adelie  Torgersen           38.9          17.8        181    3625 fema…  2007\n 8 Adelie  Torgersen           39.2          19.6        195    4675 male   2007\n 9 Adelie  Torgersen           34.1          18.1        193    3475 <NA>   2007\n10 Adelie  Torgersen           42            20.2        190    4250 <NA>   2007\n# … with 334 more rows, and abbreviated variable names ¹​flipper_length_mm,\n#   ²​body_mass_g\n# ℹ Use `print(n = ...)` to see more rows"
  },
  {
    "objectID": "clases/01-intro.html#construir-un-gráfico",
    "href": "clases/01-intro.html#construir-un-gráfico",
    "title": "Introducción a R",
    "section": "Construir un gráfico",
    "text": "Construir un gráfico\nEl paquete que vamos a utilizar para visualizar se llama ggplot, el cual es parte de tidyverse. Así que ya esta instalado cuando hicimos la llamada a la libreria tidyverse al inicio.\n\nGráfico inicial\nPrimero vamos a construir un gráfico en el cual vamos a visualizar el largo de la aleta versus el largo del pico del pinguino.\n\nggplot(data = tabla_pinguinos,\n       aes(x=flipper_length_mm, \n           y=bill_length_mm)\n       ) +\ngeom_point()\n\nWarning: Removed 2 rows containing missing values (geom_point).\n\n\n\n\n\nEn este comando lo que estamos haciendo es:\n\ndefinir los datos a usar en data = tabla_pinguinos\ndefinir la estetica (aesthetics) del grafico, en este caso el eje X y el eje Y, que son columnas de la tabla: aes(x=flipper_length_mm, y=bill_length_mm)\ndefinir que queremos hacer con los datos. En este caso, dibujar puntos: geom_point()\n\n\n\nAgregar color y formas\nComo podemos diferencias variables dentro de nuestras columnas. Agregando en la opciones de estética del gráfico dos nuevas variables: color=species, shape=sex. En este caso, asignamos color en base a los elementos distintos de la columna species y forma de los puntos en base a la columna sex. Así, el código queda:\n\nggplot(data = tabla_pinguinos,\n       aes(x=flipper_length_mm, \n           y=bill_length_mm,\n           color = species,\n           shape = sex)\n       ) +\ngeom_point()\n\nWarning: Removed 11 rows containing missing values (geom_point).\n\n\n\n\n\n\n\nCambiar color y diseño\nYa tenemos un gráfico inicial que muestra la comparación que nos interesa y ahora podemos editar para que se vea un poco mejor y no con los colores y diseño por defecto de R. Esto lo podemos hacer modificando el theme del gráfico. Mas adelante vamos a ver el detalle de como modificar diferentes componentes, pero por ahora podemos hacer un cambio general agregando el comando theme_minimal().\nEn los colores, también los podemos modificar a gusto. Por el momento vamos a utilizar una paleta de colores diferente con el comando scale_color_brewer(type = \"qual\"). En este caso le pasamos como parametro al comando scale_color_brewer la opción type = “qual”. Con esto definimos que la escala de colores es cualitativa (versus una escala cuantitativa).\nAsí el comando nos queda ahora como:\n\nggplot(data = tabla_pinguinos,\n       aes(x=flipper_length_mm, \n           y=bill_length_mm,\n           color = species,\n           shape = sex)\n       ) +\ngeom_point() +\ntheme_minimal() +\nscale_color_brewer(type=\"qual\")\n\nWarning: Removed 11 rows containing missing values (geom_point).\n\n\n\n\n\n\n\nAgregar leyendas y cambiar texto\nFinalmente, vamos a cambiar el texto que describe los ejes X e Y, y agregar algo de texto informativo.\nEsto lo vamos a hacer agregando el comando labs y definiendo las diferentes opciones:\nlabs(x=\"Flipper length (mm)\",\n     y=\"Bill length (mm)\",\n     title = \"Penguin data comparison\",\n     subtitle = \"Comparison between flipper length and bill length in a penguin population\",\n     caption = \"Data obtained from the package palmerpenguins\"\nY podemos agregarlo al gráfico.\n\nggplot(data = tabla_pinguinos,\n       aes(x=flipper_length_mm, \n           y=bill_length_mm,\n           color = species,\n           shape = sex)\n       ) +\ngeom_point() +\ntheme_minimal() +\nscale_color_brewer(type=\"qual\") +\nlabs(x=\"Flipper length (mm)\",\n     y=\"Bill length (mm)\",\n     title = \"Penguin data comparison\",\n     subtitle = \"Comparison between flipper length and bill length in a penguin population\",\n     caption = \"Data obtained from the package palmerpenguins\")\n\nWarning: Removed 11 rows containing missing values (geom_point)."
  },
  {
    "objectID": "clases/02-Tidyverse1.html",
    "href": "clases/02-Tidyverse1.html",
    "title": "Workflow de análisis",
    "section": "",
    "text": "En esta segunda clase, vamos a empezar el análisis con Tidyverse. Primero vamos a recordar como crear y establecer los directorios de trabajo. Luego vamos a explorar diferentes formas de leer datos desde diferentes tipos de tablas.\n\n\nComo vimos durante la clase, necesitamos que R sepa en que directorio vamos a trabajar. Por ejemplo, si creamos un nuevo script, para saber en donde va a quedar guardado y además el directorio de trabajo, podemos ocupar el comando getwd(). Esto nos entrega el directrio de trabajo. Por ejemplo en mi caso es:\n\ngetwd()\n\n[1] \"/Users/jugalde/websites/courses/2022-DataR/clases\"\n\n\nPara poder establecer el directorio de trabajo lo podemos hacer desde la interfaz de RStudio como vimos durante la clase, o tambien ocupando el comando setwd(). Por ejemplo:\nsetwd(\"/directorio/de/trabajo/\")\nMas detalles los iremos viendo durtante la clase\n\n\n\nEn esta sección vamos a ver como leer archivos y algunas operaciones básicas usando la libreria Tidyverse. Recuerda que antes de utilizar esta libreria hay que llamarla en el script o comandos previamente:\n\nlibrary(tidyverse)\n\n\n\nLos archivos CSV son archivos en donde cada columna esta separada por comas. Para poder leer este tipo de archivos, la libreria readr (que es parte del Tidyverse), tiene una función llamada read_csv. Por ejemplo:\n\n# Este comando va a leer un archivo csv y guardarlo en la variable gapminder\ngapminder <- read_csv(\"datos/gapminder.csv\")\ngapminder\n\n# A tibble: 1,704 × 6\n   country     continent  year lifeExp      pop gdpPercap\n   <chr>       <chr>     <dbl>   <dbl>    <dbl>     <dbl>\n 1 Afghanistan Asia       1952    28.8  8425333      779.\n 2 Afghanistan Asia       1957    30.3  9240934      821.\n 3 Afghanistan Asia       1962    32.0 10267083      853.\n 4 Afghanistan Asia       1967    34.0 11537966      836.\n 5 Afghanistan Asia       1972    36.1 13079460      740.\n 6 Afghanistan Asia       1977    38.4 14880372      786.\n 7 Afghanistan Asia       1982    39.9 12881816      978.\n 8 Afghanistan Asia       1987    40.8 13867957      852.\n 9 Afghanistan Asia       1992    41.7 16317921      649.\n10 Afghanistan Asia       1997    41.8 22227415      635.\n# … with 1,694 more rows\n# ℹ Use `print(n = ...)` to see more rows\n\n\nEn este caso vemos que el archivo fue leido correctamente y consiste en 1704 observaciones en 6 columnas.\n\n\n\nEn númerosas ocasiones nos vamos a encontrar con que los archivos que necesitamos leer, no vienen en el formato adecuado. Por ejemplo, si tratamos de leer este archivo con el comando read_csv nos damos cuenta que tenemos problemas:\n\ngapminder2 <- read_csv(\"datos/gapminder_csv2.csv\")\n\nWarning: One or more parsing issues, see `problems()` for details\n\ngapminder2\n\n# A tibble: 1,704 × 1\n   `country;continent;year;lifeExp;pop;gdpPercap`       \n   <chr>                                                \n 1 Afghanistan;Asia;1952;28,80100;   8425333;   779,4453\n 2 Afghanistan;Asia;1957;30,33200;   9240934;   820,8530\n 3 Afghanistan;Asia;1962;31,99700;  10267083;   853,1007\n 4 Afghanistan;Asia;1967;34,02000;  11537966;   836,1971\n 5 Afghanistan;Asia;1972;36,08800;  13079460;   739,9811\n 6 Afghanistan;Asia;1977;38,43800;  14880372;   786,1134\n 7 Afghanistan;Asia;1982;39,85400;  12881816;   978,0114\n 8 Afghanistan;Asia;1987;40,82200;  13867957;   852,3959\n 9 Afghanistan;Asia;1992;41,67400;  16317921;   649,3414\n10 Afghanistan;Asia;1997;41,76300;  22227415;   635,3414\n# … with 1,694 more rows\n# ℹ Use `print(n = ...)` to see more rows\n\n\nEn este caso, vemos que al leer esta tabla, queda en una sola columna. Esto se debe a que la separación de las columnas no es con comas, si no que un caracter diferente (en este caso punto y coma). Para poder leer la tabla, tenemos que ocupar otro comando en donde definimos el tipo de delimitador que separa a las columnas. En este caso ocupamos la función read_delim:\n\ngapminder2_fixed <- read_delim(\n    \"datos/gapminder_csv2.csv\",\n    delim = \";\"\n)\ngapminder2_fixed\n\n# A tibble: 1,704 × 6\n   country     continent  year lifeExp pop          gdpPercap    \n   <chr>       <chr>     <dbl>   <dbl> <chr>        <chr>        \n 1 Afghanistan Asia       1952 2880100 \"   8425333\" \"   779,4453\"\n 2 Afghanistan Asia       1957 3033200 \"   9240934\" \"   820,8530\"\n 3 Afghanistan Asia       1962 3199700 \"  10267083\" \"   853,1007\"\n 4 Afghanistan Asia       1967 3402000 \"  11537966\" \"   836,1971\"\n 5 Afghanistan Asia       1972 3608800 \"  13079460\" \"   739,9811\"\n 6 Afghanistan Asia       1977 3843800 \"  14880372\" \"   786,1134\"\n 7 Afghanistan Asia       1982 3985400 \"  12881816\" \"   978,0114\"\n 8 Afghanistan Asia       1987 4082200 \"  13867957\" \"   852,3959\"\n 9 Afghanistan Asia       1992 4167400 \"  16317921\" \"   649,3414\"\n10 Afghanistan Asia       1997 4176300 \"  22227415\" \"   635,3414\"\n# … with 1,694 more rows\n# ℹ Use `print(n = ...)` to see more rows\n\n\nEn otros casos, el formato de la tabla puede ser el adecuado, pero el archivo mismo incluir información que queremos ignorar al momento de importar los datos en R. Por ejemplo:\n\ngapminder3 <- read_csv(\"datos/gapminder_messier.csv\")\n\nWarning: One or more parsing issues, see `problems()` for details\n\ngapminder3\n\n# A tibble: 1,706 × 1\n   `# Some comment about the data`                  \n   <chr>                                            \n 1 And maybe a personal note                        \n 2 country,continent,year,lifeExp,pop,gdpPercap     \n 3 Afghanistan,Asia,1952,28.801,8425333,779.4453145 \n 4 Afghanistan,Asia,1957,30.332,9240934,820.8530296 \n 5 Afghanistan,Asia,1962,31.997,10267083,853.10071  \n 6 Afghanistan,Asia,1967,34.02,11537966,836.1971382 \n 7 Afghanistan,Asia,1972,36.088,13079460,739.9811058\n 8 Afghanistan,Asia,1977,38.438,14880372,786.11336  \n 9 Afghanistan,Asia,1982,39.854,12881816,978.0114388\n10 Afghanistan,Asia,1987,40.822,13867957,852.3959448\n# … with 1,696 more rows\n# ℹ Use `print(n = ...)` to see more rows\n\n\nEn este caso, R entrega un mensaje de aviso, porque hay columna que no tienen el formato adecuado. Al ver el resultado, vemos que las dos primeras lineas contienen información como texto, pero no son parte de las columnas. En este caso podemos ignorar esas dos primeras filas al momento de leer el archivo:\n\ngapminder3_fixed <- read_delim(\n    \"datos/gapminder_messier.csv\",\n    skip=2,\n    delim = \",\"\n)\ngapminder3_fixed\n\n# A tibble: 1,704 × 6\n   country     continent  year lifeExp      pop gdpPercap\n   <chr>       <chr>     <dbl>   <dbl>    <dbl>     <dbl>\n 1 Afghanistan Asia       1952    28.8  8425333      779.\n 2 Afghanistan Asia       1957    30.3  9240934      821.\n 3 Afghanistan Asia       1962    32.0 10267083      853.\n 4 Afghanistan Asia       1967    34.0 11537966      836.\n 5 Afghanistan Asia       1972    36.1 13079460      740.\n 6 Afghanistan Asia       1977    38.4 14880372      786.\n 7 Afghanistan Asia       1982    39.9 12881816      978.\n 8 Afghanistan Asia       1987    40.8 13867957      852.\n 9 Afghanistan Asia       1992    41.7 16317921      649.\n10 Afghanistan Asia       1997    41.8 22227415      635.\n# … with 1,694 more rows\n# ℹ Use `print(n = ...)` to see more rows\n\n\n\n\n\n\nUna vez que tenemos la información en R, podemos ocupar diferentes funciones para explorar estos datos. Vamos usar la tabla gapminder\n\ngapminder\n\n# A tibble: 1,704 × 6\n   country     continent  year lifeExp      pop gdpPercap\n   <chr>       <chr>     <dbl>   <dbl>    <dbl>     <dbl>\n 1 Afghanistan Asia       1952    28.8  8425333      779.\n 2 Afghanistan Asia       1957    30.3  9240934      821.\n 3 Afghanistan Asia       1962    32.0 10267083      853.\n 4 Afghanistan Asia       1967    34.0 11537966      836.\n 5 Afghanistan Asia       1972    36.1 13079460      740.\n 6 Afghanistan Asia       1977    38.4 14880372      786.\n 7 Afghanistan Asia       1982    39.9 12881816      978.\n 8 Afghanistan Asia       1987    40.8 13867957      852.\n 9 Afghanistan Asia       1992    41.7 16317921      649.\n10 Afghanistan Asia       1997    41.8 22227415      635.\n# … with 1,694 more rows\n# ℹ Use `print(n = ...)` to see more rows\n\n\nVemos que esta tabla tiene 6 columnas: - country - continent - year - lifeExp - pop - gdpPercap\n\n\nSi quisieramos elegir algunas columnas desde la tabla completa, podemos ocupar la función select. En este caso indicamos a la función la fuente de los datos ( gapminder ) y las columnas a elegir (country, year, pop)\n\nselect(gapminder,\n       country, year, pop)\n\n# A tibble: 1,704 × 3\n   country      year      pop\n   <chr>       <dbl>    <dbl>\n 1 Afghanistan  1952  8425333\n 2 Afghanistan  1957  9240934\n 3 Afghanistan  1962 10267083\n 4 Afghanistan  1967 11537966\n 5 Afghanistan  1972 13079460\n 6 Afghanistan  1977 14880372\n 7 Afghanistan  1982 12881816\n 8 Afghanistan  1987 13867957\n 9 Afghanistan  1992 16317921\n10 Afghanistan  1997 22227415\n# … with 1,694 more rows\n# ℹ Use `print(n = ...)` to see more rows\n\n\nTambién podemos elegir columnas en base a los nombres de estas. Por ejemplo seleccionar todas las columnas que parten con la letra c:\n\nselect(gapminder, starts_with(\"c\"))\n\n# A tibble: 1,704 × 2\n   country     continent\n   <chr>       <chr>    \n 1 Afghanistan Asia     \n 2 Afghanistan Asia     \n 3 Afghanistan Asia     \n 4 Afghanistan Asia     \n 5 Afghanistan Asia     \n 6 Afghanistan Asia     \n 7 Afghanistan Asia     \n 8 Afghanistan Asia     \n 9 Afghanistan Asia     \n10 Afghanistan Asia     \n# … with 1,694 more rows\n# ℹ Use `print(n = ...)` to see more rows\n\n\n\n\n\nAsi como select nos permite seleccionar columnas en base a los nombres, con el comando filter podemos seleccionar filas en base a los valores que estan presentes. Por ejemplo, podemos elegir todas los valores para el pais Chile:\n\nfilter(gapminder,\n       country == \"Chile\")\n\n# A tibble: 12 × 6\n   country continent  year lifeExp      pop gdpPercap\n   <chr>   <chr>     <dbl>   <dbl>    <dbl>     <dbl>\n 1 Chile   Americas   1952    54.7  6377619     3940.\n 2 Chile   Americas   1957    56.1  7048426     4316.\n 3 Chile   Americas   1962    57.9  7961258     4519.\n 4 Chile   Americas   1967    60.5  8858908     5107.\n 5 Chile   Americas   1972    63.4  9717524     5494.\n 6 Chile   Americas   1977    67.1 10599793     4757.\n 7 Chile   Americas   1982    70.6 11487112     5096.\n 8 Chile   Americas   1987    72.5 12463354     5547.\n 9 Chile   Americas   1992    74.1 13572994     7596.\n10 Chile   Americas   1997    75.8 14599929    10118.\n11 Chile   Americas   2002    77.9 15497046    10779.\n12 Chile   Americas   2007    78.6 16284741    13172.\n\n\nTambién podemos elegir varios paises a la vez, pasando un vector y ocupando el comando %in%:\n\nfilter(gapminder,\n       country %in% c(\"Chile\", \"Argentina\"))\n\n# A tibble: 24 × 6\n   country   continent  year lifeExp      pop gdpPercap\n   <chr>     <chr>     <dbl>   <dbl>    <dbl>     <dbl>\n 1 Argentina Americas   1952    62.5 17876956     5911.\n 2 Argentina Americas   1957    64.4 19610538     6857.\n 3 Argentina Americas   1962    65.1 21283783     7133.\n 4 Argentina Americas   1967    65.6 22934225     8053.\n 5 Argentina Americas   1972    67.1 24779799     9443.\n 6 Argentina Americas   1977    68.5 26983828    10079.\n 7 Argentina Americas   1982    69.9 29341374     8998.\n 8 Argentina Americas   1987    70.8 31620918     9140.\n 9 Argentina Americas   1992    71.9 33958947     9308.\n10 Argentina Americas   1997    73.3 36203463    10967.\n# … with 14 more rows\n# ℹ Use `print(n = ...)` to see more rows\n\n\nY podemos combinar diferentes filtros ocupando operadores booleanos. En este caso seleccionando pais y un año.\n\nfilter(gapminder,\n       country %in% c(\"Chile\", \"Argentina\") & year > 2000)\n\n# A tibble: 4 × 6\n  country   continent  year lifeExp      pop gdpPercap\n  <chr>     <chr>     <dbl>   <dbl>    <dbl>     <dbl>\n1 Argentina Americas   2002    74.3 38331121     8798.\n2 Argentina Americas   2007    75.3 40301927    12779.\n3 Chile     Americas   2002    77.9 15497046    10779.\n4 Chile     Americas   2007    78.6 16284741    13172.\n\n\n\n\n\nAsi como podemos seleccionar valores y columnas, también podemos crear nuevas columnas usando otras. Por ejemplo, calculemos el gdp para cada fila:\n\nmutate(gapminder,\n       gdp = pop * gdpPercap)\n\n# A tibble: 1,704 × 7\n   country     continent  year lifeExp      pop gdpPercap          gdp\n   <chr>       <chr>     <dbl>   <dbl>    <dbl>     <dbl>        <dbl>\n 1 Afghanistan Asia       1952    28.8  8425333      779.  6567086330.\n 2 Afghanistan Asia       1957    30.3  9240934      821.  7585448670.\n 3 Afghanistan Asia       1962    32.0 10267083      853.  8758855797.\n 4 Afghanistan Asia       1967    34.0 11537966      836.  9648014150.\n 5 Afghanistan Asia       1972    36.1 13079460      740.  9678553274.\n 6 Afghanistan Asia       1977    38.4 14880372      786. 11697659231.\n 7 Afghanistan Asia       1982    39.9 12881816      978. 12598563401.\n 8 Afghanistan Asia       1987    40.8 13867957      852. 11820990309.\n 9 Afghanistan Asia       1992    41.7 16317921      649. 10595901589.\n10 Afghanistan Asia       1997    41.8 22227415      635. 14121995875.\n# … with 1,694 more rows\n# ℹ Use `print(n = ...)` to see more rows\n\n\nEn este caso creamos una nueva columna llamada gdp , la cual es el resultado de la multiplicacion de las columnas pop (población) y gdpPercap (el gdp per capita).\n\n\n\nPodemos combinar diferentes funciones en un mismo pipeline ocupando el comando %>% para concatenar diferentes pasos. Asi, podemos combinar varias funciones. En este caso lo que vamos a hacer es tomar la tabla gapminder, aplicar un filtro, luego calcular una nueva columna y finalmente seleccionar columnas de interes:\n\ngapminder %>%\n    filter(year > 2000) %>%\n    mutate(gdp = pop * gdpPercap) %>%\n    select(country, year, gdp)\n\n# A tibble: 284 × 3\n   country      year           gdp\n   <chr>       <dbl>         <dbl>\n 1 Afghanistan  2002  18363410424.\n 2 Afghanistan  2007  31079291949.\n 3 Albania      2002  16153932130.\n 4 Albania      2007  21376411360.\n 5 Algeria      2002 165447670333.\n 6 Algeria      2007 207444851958.\n 7 Angola       2002  30134833901.\n 8 Angola       2007  59583895818.\n 9 Argentina    2002 337223430800.\n10 Argentina    2007 515033625357.\n# … with 274 more rows\n# ℹ Use `print(n = ...)` to see more rows\n\n\nAl igual que veamis anteriormente, podemos tambien asignar los resultados de los análisis a una nueva variable, guardando asi los resultados. Por ejemplo:\n\ngdp_2000 <- gapminder %>%\n    filter(year > 2000) %>%\n    mutate(gdp = pop * gdpPercap) %>%\n    select(country, year, gdp)\ngdp_2000\n\n# A tibble: 284 × 3\n   country      year           gdp\n   <chr>       <dbl>         <dbl>\n 1 Afghanistan  2002  18363410424.\n 2 Afghanistan  2007  31079291949.\n 3 Albania      2002  16153932130.\n 4 Albania      2007  21376411360.\n 5 Algeria      2002 165447670333.\n 6 Algeria      2007 207444851958.\n 7 Angola       2002  30134833901.\n 8 Angola       2007  59583895818.\n 9 Argentina    2002 337223430800.\n10 Argentina    2007 515033625357.\n# … with 274 more rows\n# ℹ Use `print(n = ...)` to see more rows\n\n\n\n\n\nUna operación común que vamos a querar hacer con una tabla es calcular estadisticas. Por ejemplo, el promedio de ciertas columnas o aun mas, agrupar por caracteristicas y luego calcular el promedio. Esto lo podemos hacer utilizando el comando group_by, el cual nos permite agrupar los resultados de una tabla en función de los valores de una o mas columnas. Esto lo podemos combinar con summarise, para calcular valores en base al resultado de esa agrupación. Por ejemplo, calculemos el promedio (mean) y la desviación estandar (sd) de las poblaciones por continente:\n\npop_continent_2007 <- gapminder %>%\n    filter(year == 2007)  %>%\n    group_by(continent) %>%\n    summarise(pop_promedio = mean(pop),\n              pop_dev = sd(pop),\n              gdp_promedio = mean(gdpPercap))\n\npop_continent_2007\n\n# A tibble: 5 × 4\n  continent pop_promedio    pop_dev gdp_promedio\n  <chr>            <dbl>      <dbl>        <dbl>\n1 Africa       17875763.  24917726.        3089.\n2 Americas     35954847.  68833781.       11003.\n3 Asia        115513752. 289673399.       12473.\n4 Europe       19536618.  23624744.       25054.\n5 Oceania      12274974.  11538855.       29810.\n\n\nEl comando summarise entrega una nueva tabla resumida. Si solo queremos agregar una nueva columna en base al resultado del agrupamiento, podemos ocupar mutate. Por ejemplo:\n\npctPop_table <- gapminder %>%\n    group_by(continent, year) %>%\n    mutate(pctPop = pop / sum(pop) * 100)\n\npctPop_table\n\n# A tibble: 1,704 × 7\n# Groups:   continent, year [60]\n   country     continent  year lifeExp      pop gdpPercap pctPop\n   <chr>       <chr>     <dbl>   <dbl>    <dbl>     <dbl>  <dbl>\n 1 Afghanistan Asia       1952    28.8  8425333      779.  0.604\n 2 Afghanistan Asia       1957    30.3  9240934      821.  0.591\n 3 Afghanistan Asia       1962    32.0 10267083      853.  0.605\n 4 Afghanistan Asia       1967    34.0 11537966      836.  0.605\n 5 Afghanistan Asia       1972    36.1 13079460      740.  0.608\n 6 Afghanistan Asia       1977    38.4 14880372      786.  0.624\n 7 Afghanistan Asia       1982    39.9 12881816      978.  0.494\n 8 Afghanistan Asia       1987    40.8 13867957      852.  0.483\n 9 Afghanistan Asia       1992    41.7 16317921      649.  0.521\n10 Afghanistan Asia       1997    41.8 22227415      635.  0.657\n# … with 1,694 more rows\n# ℹ Use `print(n = ...)` to see more rows"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "1 + 1\n\n[1] 2"
  },
  {
    "objectID": "syllabus.html",
    "href": "syllabus.html",
    "title": "Syllabus",
    "section": "",
    "text": "Temas que veremos en este curso:"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "DataViz 2022",
    "section": "",
    "text": "Bienvenid@s al curso de análisis y visualización de datos usando R, Tidyverse y Quarto.\nEn la parte superior derecha de esta página encontraran el link al material de las clases y las tareas que iremos trabajando cada semana.\nOJO Antes de nuestra primera clase el próximo Martes 16, es necesario que traigan instalado en sus computadores R, Rstudio y las librerias que vamos a utilizar. Mas información la pueden encontrar aqui, en la sección de pre-requisitos.\n\nProfesor\n\n   Juan A. Ugalde\n   juan.ugalde@unab.cl\n\n\n\nDetalles del curso\n\n   Martes, 9:25 am - 11:05 am\n   Sala de seminarios CBIB"
  }
]